"""
These functions are used to generate synthetic time series.
"""

import numpy as np
from typing import Union, List, Optional

import tensorflow as tf
from keras.backend import floatx

from ..utils import np_range_dims


def random_ts(
    n_steps: int = 100,
    trend_degree: int = 2,
    periods: List[int] = [10],
    fourier_orders: List[int] = 10,
    trend_mean: Optional[int] = 0,
    trend_std: Optional[int] = 1,
    seasonality_mean: Optional[int] = 0,
    seasonality_std: Optional[int] = 1,
    batch_size: Optional[Union[List[int], int]] = None,
    n_variables: Optional[int] = 1,
    noise: Optional[bool] = False,
    seed: Optional[int] = None,
) -> np.ndarray:

    """
    Generate random time series composed by a trend and seasonality components.

    Trend and seasonality coefficients are generated by a Gaussian distribution.

    Parameters
    ----------
    n_steps : int
        Number of steps.
    trend_degree : int
        Number of degree for the trend function. Usually 1 or 2.
    periods : list[int]
        Computes the seasonality component.
        A period lower than n_step leads to a pattern which is repeating.
    fourier_orders : int
        Computes the complexity of the seasonality component.
        Higher order means higher complexity.
    trend_mean : int
        Mean value associated to the trend component.
        Default to 0.
    trend_std : int
        Deviation value associated to the trend component.
        Default to 1.
    seasonality_mean : int
        Mean value associated to the seasonality component.
        Default to 0.
    seasonality_std : int
        Deviation value associated to the seasonality component.
        Default to 1.
    batch_size : int or list[int] or None
        Computes the batch_size of the time series.
        Default to None.
    n_variables : int
        Number of variables.
        Default to 1.
    noise : boolean
        Add centered normal distributed noise to the series.
        Default to False.
    seed : int or None
        Allow reproducible results.
        Default to None.

    Returns
    -------
    time_series : `array of shape [D0, ..., n_variables, n_steps]`
        Time series defined by a random process.

    Examples
    --------
    >>> from autopycoin.data import random_ts
    >>> data = random_ts(n_steps=10,
    ...                  trend_degree=2,
    ...                  periods=[10],
    ...                  fourier_orders=[10],
    ...                  trend_mean=0,
    ...                  trend_std=1,
    ...                  seasonality_mean=0,
    ...                  seasonality_std=1,
    ...                  batch_size=None,
    ...                  n_variables=1,
    ...                  noise=True,
    ...                  seed=42)
    >>> data.shape
    TensorShape([10, 1])

    Notes
    -----
    
    Mathematical details:

    .. math:: f(t) = T(t) + S(t) X(e^{j\omega } ) = x(n)e^{ - j\omega n}

    .. math:: with T(t) = AX 
    .. math:: and S(t) = BX_1 + CX_2
    .. math:: X_1 = \sin(2\times \pi \times X_s)
    .. math:: X_2 = \cos(2\times \pi \times X_s)
    
    T is the trend matrix and S defines the seasonality matrix,
    A defines the trend coefficients matrix of dimension (batch size, variables, degree),
    B defines the sinus coefficients matrix of dimension (batch size, variables, fourier order),
    C defines the cosinus coefficients matrix of dimension (batch size, variables, fourier order),
    X is the time matrix of dimension (degree, time),
    X_s is the time matrix of dimension (period, time).
    """

    np.random.seed(seed)

    if isinstance(batch_size, int):
        batch_size = [batch_size]
    elif batch_size is None:
        batch_size = []

    degree = np_range_dims(trend_degree, shape=(-1, 1))
    time = np_range_dims(n_steps, shape=(1, -1))

    # Workout random trend coefficients
    trend_coef = np.random.normal(
        size=(*batch_size, n_variables, trend_degree),
        loc=trend_mean,
        scale=trend_std,
    )

    time_series = trend_coef @ ((time / n_steps) ** degree)

    # Shape (-1, 1) in order to broadcast periods to all time units
    periods = np.reshape(periods, (-1, 1))
    periods = periods.astype(floatx())

    time = 2 * np.pi * time / periods
    fourier_orders = np_range_dims(fourier_orders, shape=(-1, 1))
    seasonality = time * fourier_orders

    # Workout cos and sin seasonality coefficents
    seasonality = np.vstack((tf.cos(seasonality), tf.sin(seasonality)))

    # Workout random seasonality coefficents
    seas_coef = np.random.normal(
        size=(*batch_size, n_variables, seasonality.shape[0]),
        loc=seasonality_mean,
        scale=seasonality_std,
    )

    seasonality = seas_coef @ seasonality

    # Seasonality coefficients added to ts
    time_series = time_series + seasonality

    if noise:
        noise = np.random.normal(
            (n_steps, 1), mean=0.0, stddev=1, dtype=floatx(), seed=seed
        )
        return time_series + noise
    return time_series